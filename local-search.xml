<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对于旁路盲注攻击的缓解：RFC5961</title>
    <link href="/2023/11/07/RFC5961/"/>
    <url>/2023/11/07/RFC5961/</url>
    
    <content type="html"><![CDATA[<h2 id="RFC5961-之前"><a href="#RFC5961-之前" class="headerlink" title="RFC5961 之前"></a>RFC5961 之前</h2><p>tcp 连接面临旁路攻击者的威胁，旁路攻击者可以通过盲注 RST，ACK，DATA 报文的方式来关闭，重置连接或者注入数据。<br>旁路攻击者与 MITM 攻击者相对，其不在通信链路上，无法窃听到链路上的报文。</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="RST-攻击"><a href="#RST-攻击" class="headerlink" title="RST 攻击"></a>RST 攻击</h4><ul><li><strong>描述</strong>：攻击者发送一个设置了 RST（重置）标志的 TCP 段。</li><li><strong>目的</strong>：通过使接收端认为另一端已发出终止连接的信号，以提前终止 TCP 连接。</li><li><strong>开销</strong>：平均需要$2^{31}/window$个报文完成攻击</li></ul><h4 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h4><ul><li><strong>描述</strong>：攻击者发送一个设置了 SYN（同步）标志的 TCP 段。</li><li><strong>目的</strong>：欺骗接收者，使其认为发送者已经发起了一个新的连接请求，导致现有连接状态被拆除。</li><li><strong>开销</strong>：平均需要$2^{31}/window$个报文完成攻击</li></ul><h4 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h4><ul><li><strong>描述</strong>：攻击者尝试注入包含有效载荷数据的 TCP 段。</li><li><strong>目的</strong>：破坏正在进行的传输的数据，导致数据完整性问题。</li><li><strong>开销</strong>：平均需要$2^{32}/window$个报文完成攻击，这里因为数据报文需要检验 ACK 字段，即需要满足如下关系$(SND.UNA-(2^31-1)) &lt;= SEG.ACK &lt;= SND.NXT$.对于每个猜测的 SEQ 需要 ACK 空间（32 比特循环群）上的两个元素才能确保被接受。</li></ul><p>过去通常认为这种攻击是不会发生的，因为$2^{32}$的序列空间使得$SEG.SEQ == RCV.NXT$概率极小，但实际并非如此，seq 号只需要命中窗口即可（$RCV.NXT &lt;= SEG.SEQ &lt; RCV.NXT+RCV.WND$），攻击者实际上平均只需要$2^{31}/window$个报文即可完成完成攻击。这在当前的接入带宽下是非常容易完成的。</p><h3 id="RFC5961-缓解-1-措施"><a href="#RFC5961-缓解-1-措施" class="headerlink" title="RFC5961 缓解[1]措施"></a>RFC5961 缓解<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="~~TCP 这个白左创造的乌托邦适用的通信协议因为兼容性问题确实难以替代，只能通过这种打补丁的形式来修漏洞。~~">[1]</span></a></sup>措施</h3><h3 id="SYN-攻击的缓解措施"><a href="#SYN-攻击的缓解措施" class="headerlink" title="SYN 攻击的缓解措施"></a>SYN 攻击的缓解措施</h3><ol><li><p><strong>挑战 ACK</strong>:</p><ul><li>不论序列号如何，如果接收到的 TCP 段设置了 SYN 位，TCP 必须向远程对等方发送 ACK 响应（挑战 ACK）。</li><li>发送格式为 <code>&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</code>。</li><li>发送挑战 ACK 后，TCP 必须丢弃该段，并停止进一步处理。</li></ul></li><li><p><strong>合法对等方的行为</strong>:</p><ul><li>合法的对等方在重启后不应在同步状态下有 TCP 控制块（TCB）。</li><li>当挑战 ACK 到达时，如果对等方确实重新启动了，它应响应一个 RST 段，序列号基于引起 RST 的 ACK 字段。</li></ul></li><li><p><strong>伪造 SYN 的处理</strong>:</p><ul><li>伪造的 SYN 将产生一个额外的 ACK。</li><li>远程对等方将这个额外的 ACK 视为重复的 ACK 并丢弃，从而不影响已建立的连接。</li></ul></li><li><p><strong>非放大 ACK 交换</strong>:</p><ul><li>这种缓解措施可能导致非放大的 ACK 交换，即不会增加网络流量的 ACK 响应。</li></ul></li></ol><h3 id="RST-攻击的缓解措施"><a href="#RST-攻击的缓解措施" class="headerlink" title="RST 攻击的缓解措施"></a>RST 攻击的缓解措施</h3><ol><li><p><strong>挑战 ACK</strong>:</p><ul><li>如果 RST 位被设置并且序列号不完全匹配下一个预期的序列值，但在当前接收窗口内，TCP 必须发送一个确认（挑战 ACK）。</li><li>发送格式为 <code>&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</code>。</li><li>发送挑战 ACK 后，TCP 必须丢弃不可接受的段，并停止进一步处理进来的包。接下来的对这个连接的段将正常处理。</li></ul></li><li><p><strong>RST 段的处理</strong>:</p><ul><li>在除 SYN-SENT 外的所有状态中，所有重置（RST）段都通过检查它们的序列号字段来验证。</li><li>如果 RST 段到达并且其序列号字段不匹配下一个预期的序列号但在窗口内，则接收者应该生成一个 ACK。</li><li>在其他所有情况下，如果序列号不匹配且在窗口外，接收者必须默默丢弃该段。</li></ul></li><li><p><strong>远程对等方生成 RST</strong>:</p><ul><li>如果远程对等方确实生成了一个 RST，但它未满足上述标准（RST 序列号在窗口内但不是确切预期的序列号），当挑战 ACK 发回时，它将不再有与此连接相关的传输控制块（TCB），因此根据 RFC 793，远程对等方将发回第二个 RST。</li><li>第二个 RST 的序列号来自入站 ACK 的确认号。如果第二个 RST 到达发送方，将导致连接中止，因为序列号现在完全匹配。</li></ul></li></ol><h3 id="数据注入攻击的缓解措施"><a href="#数据注入攻击的缓解措施" class="headerlink" title="数据注入攻击的缓解措施"></a>数据注入攻击的缓解措施</h3><ol><li><p><strong>ACK 值的校验</strong>:</p><ul><li>所有 TCP 栈都可以实施以下缓解措施。实施此缓解措施的 TCP 栈必须对任何进入的段添加一个额外的输入检查。</li><li>ACK 值只有在 <code>((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK &lt;= SND.NXT)</code> 范围内才被认为是可接受的。</li><li>所有 ACK 值不满足上述条件的进入段必须被丢弃，并且回送一个 ACK。</li></ul></li><li><p><strong>MAX.SND.WND 状态变量</strong>:</p><ul><li>定义一个新的状态变量 MAX.SND.WND，作为本地发送方曾经从其对等方接收到的最大窗口。</li><li>这个小检查将减少攻击者猜测一个有效序列号的脆弱性，因为不仅要猜到窗口内的序列号，还要猜到一个在特定范围内的正确 ACK 值。</li></ul></li><li><p><strong>提高对 FIN 段的健壮性</strong>:</p><ul><li>这种缓解措施还有助于提高对接受伪造 FIN 段（FIN 攻击）的健壮性。</li><li>攻击者也需要让确认号落在上述范围内，以成功伪造一个 FIN 段导致连接关闭。</li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>文档对于这三种对于 tcp 状态机的修改，前两种应该被实现，最后一种由开发者决定是否实现。因为在 RFC</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><del>TCP 这个白左创造的乌托邦适用的通信协议因为兼容性问题确实难以替代，只能通过这种打补丁的形式来修漏洞。</del><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>RFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
